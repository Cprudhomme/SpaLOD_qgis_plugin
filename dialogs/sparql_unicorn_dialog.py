# -*- coding: utf-8 -*-
"""
/***************************************************************************
 SPAQLunicornDialog
                                 A QGIS plugin
 This plugin adds a GeoJSON layer from a Wikidata SPARQL query.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2019-10-28
        git sha              : $Format:%H$
        copyright            : (C) 2019 by SPARQL Unicorn
        email                : rse@fthiery.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os
import re
import json
import sys
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.PyQt import QtCore
from qgis.core import QgsProject,QgsMessageLog, Qgis
from qgis.PyQt.QtCore import QRegExp, QSortFilterProxyModel, Qt, QUrl
from qgis.PyQt.QtGui import QRegExpValidator, QStandardItemModel, QDesktopServices
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import QMainWindow, QAction, qApp, QApplication, QFrame
from qgis.PyQt.QtWidgets import QComboBox, QCompleter, QTableWidgetItem, QHBoxLayout, QPushButton, QWidget,  \
    QAbstractItemView, QListView, QMessageBox, QApplication, QMenu, QAction
from rdflib.plugins.sparql import prepareQuery
from ..dialogs.whattoenrichdialog import EnrichmentDialog
from ..dialogs.convertcrsdialog import ConvertCRSDialog
from ..util.tooltipplaintext import ToolTipPlainText
from ..enrichmenttab import EnrichmentTab
from ..interlinkingtab import InterlinkingTab
from ..dialogs.triplestoredialog import TripleStoreDialog
from ..dialogs.triplestorequickadddialog import TripleStoreQuickAddDialog
from ..dialogs.searchdialog import SearchDialog
from ..util.sparqlhighlighter import SPARQLHighlighter
from ..dialogs.valuemappingdialog import ValueMappingDialog
from ..dialogs.bboxdialog import BBOXDialog
from ..dialogs.loadgraphdialog import LoadGraphDialog
from ..dialogs.interlinkMainWindow import InterlinkMainWindow
from ..dialogs.enrichmentMainWindow import EnrichmentMainWindow
from ..dialogs.warningLayerdlg import WarningLayerDlg



# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'ui/sparql_unicorn_dialog_base.ui'))

MESSAGE_CATEGORY = 'SPARQLUnicornDialog'
##
#  @brief The main dialog window of the SPARQLUnicorn QGIS Plugin.
class SPARQLunicornDialog(QtWidgets.QMainWindow, FORM_CLASS):
    ## The triple store configuration file
    triplestoreconf = None
    ## Prefix map
    prefixes = None

    enrichtab = None

    interlinktab = None

    conceptList = None

    completerClassList = None

    columnvars = {}

    geoClassListModel = []

    # areaconcepts = (additem)





    # currentChanged = None
    # menubar = None
    #
    # fileMenu = {}



    def __init__(self, triplestoreconf={}, prefixes=[], addVocabConf={}, autocomplete={},
                 prefixstore={"normal": {}, "reversed": {}}, savedQueriesJSON={}, maindlg=None, parent=None ):
        """Constructor."""
        super(SPARQLunicornDialog, self).__init__(parent)
        self.setupUi(self)

        # self.currentIndex = QCo
        # self.loadUnicornLayers = loadUnicornLayers()
        # self.saveQueryName = QLineEdit()
        # self.comboBox = QComboBox()
        # self.menuBar = menuBar
        self.prefixes = prefixes
        self.maindlg = maindlg
        self.savedQueriesJSON = savedQueriesJSON
        # self.enrichtab = EnrichmentTab(self)
        # self.interlinktab = InterlinkingTab(self)
        self.addVocabConf = addVocabConf
        self.autocomplete = autocomplete
        self.prefixstore = prefixstore
        self.triplestoreconf = triplestoreconf
        self.searchTripleStoreDialog = TripleStoreDialog(self.triplestoreconf, self.prefixes, self.prefixstore,self.endpointCB)



        # self.inp_sparql2 = ToolTipPlainText(self.tab, self.triplestoreconf, self.comboBox, self.columnvars,
        #                                     self.prefixes, self.autocomplete)

        # self.areaconcepts.hide()
        # self.areas.hide()
        # self.label_8.hide()
        # self.label_9.hide()
        # self.savedQueries.hide()
        # self.loadQuery.hide()
        # self.saveQueryButton.hide()
        # self.saveQueryName.hide()
        # self.savedQueryLabel.hide()
        # self.saveQueryName_2.hide()
        # self.enrichTableResult.hide()

        # To be removed
            # self.saveQueryButton.clicked.connect(self.saveQueryFunc)
            # self.convertTTLCRS.clicked.connect(self.buildConvertCRSDialog)
            # self.quickAddTripleStore.clicked.connect(self.buildQuickAddTripleStore)
            # self.loadTripleStoreButton.clicked.connect(self.buildCustomTripleStoreDialog)
            # self.loadFileButton.clicked.connect(self.buildLoadGraphDialog)

        # Enrichment
            # self.enrichTable.cellClicked.connect(self.createEnrichSearchDialog)
            # self.addEnrichedLayerButton.clicked.connect(self.enrichtab.addEnrichedLayer)
            # self.startEnrichment.clicked.connect(self.enrichtab.enrichLayerProcess)
            # self.loadLayerEnrich.clicked.connect(self.loadLayerForEnrichment)
            # self.addEnrichedLayerRowButton.clicked.connect(self.addEnrichRow)
            # self.whattoenrich.clicked.connect(self.createWhatToEnrich)
            # self.exportInterlink.clicked.connect(self.enrichtab.exportEnrichedLayer)

        # Interlink Main Window

        # self.refreshLayersInterlink.clicked.connect(self.loadUnicornLayers)
        # self.interlinkTable.cellClicked.connect(self.createInterlinkSearchDialog)
        # self.chooseLayerInterlink.clear()
        # self.searchClass.clicked.connect(self.createInterlinkSearchDialog)
        # urlregex = QRegExp("http[s]?://(?:[a-zA-Z#]|[0-9]|[$-_@.&+]|[!*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+")
        # urlvalidator = QRegExpValidator(urlregex, self)
        # self.interlinkNameSpace.setValidator(urlvalidator)
        # self.interlinkNameSpace.textChanged.connect(self.check_state3)
        # self.interlinkNameSpace.textChanged.emit(self.interlinkNameSpace.text())
        # self.exportMappingButton.clicked.connect(self.interlinktab.exportMapping)
        # self.importMappingButton.clicked.connect(self.interlinktab.loadMapping)
        # self.loadLayerInterlink.clicked.connect(self.loadLayerForInterlink)

        # Query QMainWindow codelines:

        self.inp_sparql2.move(10, 130)
        self.inp_sparql2.setMinimumSize(780, 431)
        self.inp_sparql2.document().defaultFont().setPointSize(16)
        self.inp_sparql2.setPlainText(
            "SELECT ?item ?lat ?lon WHERE {\n ?item ?b ?c .\n ?item <http://www.wikidata.org/prop:P123> ?def .\n}")
        self.inp_sparql2.columnvars = {}
        self.inp_sparql2.textChanged.connect(self.validateSPARQL)
        self.sparqlhighlight = SPARQLHighlighter(self.inp_sparql2)
        self.geoTreeView.setHeaderHidden(True)
        self.geoTreeView.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.geoTreeView.setAlternatingRowColors(True)
        self.geoTreeView.setWordWrap(True)
        self.geoTreeView.setContextMenuPolicy(Qt.CustomContextMenu)
        self.geoTreeView.customContextMenuRequested.connect(self.onContext)
        self.geoTreeViewModel = QStandardItemModel()
        self.geoTreeView.setModel(self.geoTreeViewModel)
        self.featureCollectionClassListModel = QStandardItemModel()
        self.geometryCollectionClassListModel = QStandardItemModel()
        self.proxyModel = QSortFilterProxyModel(self)
        self.proxyModel.sort(0)
        self.proxyModel.setFilterCaseSensitivity(Qt.CaseInsensitive)
        self.proxyModel.setSourceModel(self.geoTreeViewModel)
        self.featureCollectionProxyModel = QSortFilterProxyModel(self)
        self.featureCollectionProxyModel.sort(0)
        self.featureCollectionProxyModel.setFilterCaseSensitivity(Qt.CaseInsensitive)
        self.featureCollectionProxyModel.setSourceModel(self.featureCollectionClassListModel)
        self.geometryCollectionProxyModel = QSortFilterProxyModel(self)
        self.geometryCollectionProxyModel.sort(0)
        self.geometryCollectionProxyModel.setFilterCaseSensitivity(Qt.CaseInsensitive)
        self.geometryCollectionProxyModel.setSourceModel(self.geometryCollectionClassListModel)
        self.geoTreeView.setModel(self.proxyModel)
        self.geoTreeViewModel.clear()
        self.rootNode = self.geoTreeViewModel.invisibleRootItem()
        self.featureCollectionClassList.setModel(self.featureCollectionProxyModel)
        self.featureCollectionClassList.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.featureCollectionClassList.setAlternatingRowColors(True)
        self.featureCollectionClassList.setWordWrap(True)
        self.featureCollectionClassList.setContextMenuPolicy(Qt.CustomContextMenu)
        self.featureCollectionClassList.customContextMenuRequested.connect(self.onContext)
        self.featureCollectionClassListModel.clear()
        self.geometryCollectionClassList.setModel(self.geometryCollectionProxyModel)
        self.geometryCollectionClassList.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.geometryCollectionClassList.setAlternatingRowColors(True)
        self.geometryCollectionClassList.setWordWrap(True)
        self.geometryCollectionClassList.setContextMenuPolicy(Qt.CustomContextMenu)
        self.geometryCollectionClassList.customContextMenuRequested.connect(self.onContext)
        self.geometryCollectionClassListModel.clear()
        #self.queryLimit.setValidator(QRegExpValidator(QRegExp("[0-9]*")))
        self.filterConcepts.textChanged.connect(self.setFilterFromText)
        self.queryTemplates.currentIndexChanged.connect(self.viewselectaction)
        self.loadQuery.clicked.connect(self.loadQueryFunc)
        self.loadQuery.setToolTip('Will load a previously saved query')
        self.geoTreeView.selectionModel().currentChanged.connect(self.viewselectaction)
        self.actionLoad_Graph.triggered.connect(self.buildLoadGraphDialog)
        self.actionLoad_Graph.setToolTip('Will open the Load Graph dialog if selected')
        self.actionAdd_Endpoint.triggered.connect(self.buildQuickAddTripleStore)
        self.actionAdd_Endpoint.setToolTip('Will open the Add Endpoint dialog if selected')
        self.loadTripleStoreButton.clicked.connect(self.buildCustomTripleStoreDialog)
        self.loadTripleStoreButton.setToolTip('Loads your selected triplestore from the "Unicorn plugin" ')
        self.saveQueryButton.clicked.connect(self.saveQueryFunc)
        self.saveQueryButton.setToolTip('Saves your query in the "Unicorn" plugin')
        self.actionConvert_TTL_CRS.triggered.connect(self.buildConvertCRSDialog)
        self.bboxButton.clicked.connect(self.getPointFromCanvas)
        self.bboxButton.setToolTip('When clicked opens the BBOX dialog')
        self.actionInterlink.triggered.connect(self.buildInterlinkDlg)
        self.actionInterlink.setToolTip('Will open the Interlink window if selected')
        self.actionEnrichment.triggered.connect(self.buildEnrichmentDlg)
        self.actionEnrichment.setToolTip('Will open the Enrichment window if selected')
        self.btn_loadunicornlayers.clicked.connect(self.loadUnicornLayers)
        self.btn_loadunicornlayers.setToolTip('Loads the layer you selected from the "Unicorn plugin" ')
        self.loadUnicornLayers()

    def buildEnrichmentDlg(self):
        enrichmentdlg = EnrichmentMainWindow(QgsProject.instance().layerTreeRoot().children(), self.addVocabConf, self.triplestoreconf, self.prefixes, self.prefixstore, self.endpointCB, self)
        enrichmentdlg.show()

    def buildInterlinkDlg(self):
        # self.interlinkdlg = InterlinkMainWindow(self)
        # initialisation of the Interlink MainWindow
        interlinkdlg = InterlinkMainWindow(QgsProject.instance().layerTreeRoot().children(), self.maindlg, self.addVocabConf, self.triplestoreconf, self.prefixes, self.prefixstore, self.endpointCB, self)
        interlinkdlg.show()
        ##
        #  @brief Creates a What To Enrich dialog with parameters given.
        #
        #  @param self The object pointer
    def buildLoadGraphDialog(self):
        self.searchTripleStoreDialog = LoadGraphDialog(self.triplestoreconf, self.maindlg, self)
        self.searchTripleStoreDialog.setWindowTitle("Load Graph")
        self.searchTripleStoreDialog.exec_()

##
#  @brief Creates a What To Enrich dialog with parameters given.
#
#  @param self The object pointer
    def buildQuickAddTripleStore(self):

        self.searchTripleStoreDialog = TripleStoreQuickAddDialog(self.triplestoreconf, self.prefixes, self.prefixstore,
        self.endpointCB)
        self.searchTripleStoreDialog.setMinimumSize(580, 186)
        self.searchTripleStoreDialog.setWindowTitle("Configure Own Triple Store")
        self.searchTripleStoreDialog.exec_()

# builds the "buildCustomTripleStoreDialog" which pops up when the user clicks on the "loadTripleStoreButton" (Configure Triple)
    def buildCustomTripleStoreDialog(self):

        self.searchTripleStoreDialog = TripleStoreDialog(self.triplestoreconf, self.prefixes, self.prefixstore,
                                                         self.endpointCB)
        self.searchTripleStoreDialog.setMinimumSize(700, 500)
        self.searchTripleStoreDialog.setWindowTitle("Configure Own Triple Store")
        self.searchTripleStoreDialog.exec_()

    def setFilterFromText(self):
        self.proxyModel.setFilterRegExp(self.filterConcepts.text())

# this functions allows the users to save queries in a json.dump
    def saveQueryFunc(self):
        queryName = self.saveQueryName.text()
        if queryName is not None and queryName != "":
            __location__ = os.path.realpath(os.path.join(os.getcwd(), os.path.dirname(__file__)))
            if not self.triplestoreconf[self.endpointCB.currentIndex()]["endpoint"] in self.savedQueriesJSON:
                self.savedQueriesJSON[self.triplestoreconf[self.endpointCB.currentIndex()]["endpoint"]] = []
            self.savedQueriesJSON[self.triplestoreconf[self.endpointCB.currentIndex()]["endpoint"]].append(
                {"label": queryName, "query": self.inp_sparql2.toPlainText()})
            self.savedQueries.addItem(queryName)
            f = open(os.path.join(__location__, 'savedqueries.json'), "w")
            f.write(json.dumps(self.savedQueriesJSON))
            f.close()



# creates the dialog for converting CRS
    def buildConvertCRSDialog(self):
        self.searchTripleStoreDialog = ConvertCRSDialog(self.triplestoreconf, self.maindlg, self)
        self.searchTripleStoreDialog.setWindowTitle("Convert CRS")
        self.searchTripleStoreDialog.exec_()

    ## Validates the SPARQL query in the input field and outputs errors in a label.
    #  @param self The object pointer.
    def validateSPARQL(self):
        if self.prefixes is not None and self.endpointCB is not None and self.endpointCB.currentIndex() is not None and self.prefixes[
            self.endpointCB.currentIndex()] is not None and self.inp_sparql2.toPlainText() is not None and self.inp_sparql2.toPlainText() != "":
            try:
                if self.prefixes[self.endpointCB.currentIndex()] != "":
                    prepareQuery(
                        "".join(self.prefixes[self.endpointCB.currentIndex()]) + "\n" + self.inp_sparql2.toPlainText())
                self.errorLabel.setText("Valid Query")
                self.errorline = -1
                self.sparqlhighlight.errorhighlightline = self.errorline
                self.sparqlhighlight.currentline = 0
                self.inp_sparql2.errorline = None
            except Exception as e:
                match = re.search(r'line:([0-9]+),', str(e))
                match2 = re.search(r'col:([0-9]+),', str(e))
                start = int(match.group(1)) - len(self.triplestoreconf[self.endpointCB.currentIndex()]["prefixes"]) - 1
                self.errorLabel.setText(re.sub("line:([0-9]+),", "line: " + str(start) + ",", str(e)))
                self.inp_sparql2.errorline = start - 1
                if "line" in str(e):
                    ex = str(e)
                    start = ex.find('line:') + 5
                    end = ex.find(',', start)
                    start2 = ex.find('col:') + 4
                    end2 = ex.find(')', start2)
                    self.errorline = ex[start:end]
                    self.sparqlhighlight.errorhighlightcol = ex[start2:end2]
                    self.sparqlhighlight.errorhighlightline = self.errorline
                    self.sparqlhighlight.currentline = 0

# allow the user to load already savec queries
    def loadQueryFunc(self):
        if self.triplestoreconf[self.endpointCB.currentIndex()]["endpoint"] in self.savedQueriesJSON:
            self.inp_sparql2.setPlainText(
                self.savedQueriesJSON[self.triplestoreconf[self.endpointCB.currentIndex()]["endpoint"]][
                    self.savedQueries.currentIndex()]["query"])

    def viewselectaction(self,selected=None, deselected=None):

        endpointIndex = self.endpointCB.currentIndex()
        if endpointIndex == 0:
            self.justloadingfromfile = False
            return
        concept = ""
        curindex = self.proxyModel.mapToSource(self.geoTreeView.selectionModel().currentIndex())

        if self.geoTreeView.selectionModel().currentIndex() is not None and self.geoTreeViewModel.itemFromIndex(
                curindex) is not None and re.match(r'.*Q[0-9]+.*', self.geoTreeViewModel.itemFromIndex(
            curindex).text()) and not self.geoTreeViewModel.itemFromIndex(curindex).text().startswith("http"):
            self.inp_label.setText(
                self.geoTreeViewModel.itemFromIndex(curindex).text().split("(")[0].lower().replace(" ", "_"))
            concept = "Q" + self.geoTreeViewModel.itemFromIndex(curindex).text().split("Q")[1].replace(")", "")
        elif self.geoTreeViewModel.itemFromIndex(curindex) is not None:
            concept = self.geoTreeViewModel.itemFromIndex(curindex).data(1)

        if "querytemplate" in self.triplestoreconf[endpointIndex]:
            if "wd:Q%%concept%% ." in \
                    self.triplestoreconf[endpointIndex]["querytemplate"][self.queryTemplates.currentIndex()]["query"]:
                querytext = ""
                if concept != None and concept.startswith("http"):
                    querytext = \
                        self.triplestoreconf[endpointIndex]["querytemplate"][self.queryTemplates.currentIndex()][
                            "query"].replace("wd:Q%%concept%% .", "wd:" + concept[concept.rfind('/') + 1:] + " .")
                elif concept != None:
                    querytext = \
                        self.triplestoreconf[endpointIndex]["querytemplate"][self.queryTemplates.currentIndex()][
                            "query"].replace("wd:Q%%concept%% .", "wd:" + concept + " .")
            else:
                querytext = self.triplestoreconf[endpointIndex]["querytemplate"][self.queryTemplates.currentIndex()]["query"].replace("%%concept%%", concept)

            print("1")
            #if self.queryLimit.text().isnumeric() and querytext.rfind("LIMIT") != -1:
                ##print("2")
                ##querytext = querytext[0:querytext.rfind("LIMIT")] + "LIMIT " + self.queryLimit.text()
            ##elif self.queryLimit.text().isnumeric() and querytext.rfind("LIMIT") == -1:
                ##querytext = querytext + " LIMIT " + self.queryLimit.text()
            self.inp_sparql2.setPlainText(querytext)
            self.inp_sparql2.columnvars = {}
        if self.geoTreeView.selectionModel().currentIndex() is not None and self.geoTreeViewModel.itemFromIndex(
                curindex) is not None and "#" in self.geoTreeViewModel.itemFromIndex(curindex).text():
            self.inp_label.setText(self.geoTreeViewModel.itemFromIndex(curindex).text()[
                                   self.geoTreeViewModel.itemFromIndex(curindex).text().rfind(
                                       '#') + 1:].lower().replace(" ", "_"))

        elif self.geoTreeView.selectionModel().currentIndex() is not None and self.geoTreeViewModel.itemFromIndex(
                curindex) is not None:
            self.inp_label.setText(self.geoTreeViewModel.itemFromIndex(curindex).text()[
                                   self.geoTreeViewModel.itemFromIndex(curindex).text().rfind(
                                       '/') + 1:].lower().replace(" ", "_"))
    def onContext(self,position):
        menu = QMenu("Menu", self.geoTreeView)
        action = QAction("Open in Webbrowser")
        menu.addAction(action)
        action.triggered.connect(self.openURL)
        menu.exec_(self.geoTreeView.viewport().mapToGlobal(position))

    def openURL(self):
        curindex = self.proxyModel.mapToSource(self.geoTreeView.selectionModel().currentIndex())
        concept = self.geoTreeViewModel.itemFromIndex(curindex).data(2)
        url = QUrl(concept)
        QDesktopServices.openUrl(url)


    def loadUnicornLayers(self):
        layers = QgsProject.instance().layerTreeRoot().children()
        # Populate the comboBox with names of all the loaded unicorn layers
        self.loadedLayers.clear()
        # self.chooseLayerInterlink.clear()
        # self.chooseLayerEnrich.clear()
        for layer in layers:
            ucl = layer.name()
            # if type(layer) == QgsMapLayer.VectorLayer:
            self.loadedLayers.addItem(layer.name())
            # self.chooseLayerInterlink.addItem(layer.name())
            # self.chooseLayerEnrich.addItem(layer.name())

        ##
        #  @brief Builds the search dialog to search for a concept or class.
        #  @param  self The object pointer
        #  @param  row the row to insert the result
        #  @param  column the column to insert the result
        #  @param  interlinkOrEnrich indicates if the dialog is meant for interlinking or enrichment
        #  @param  table the GUI element to display the result
    def buildSearchDialog(self, row, column, interlinkOrEnrich, table, propOrClass, bothOptions=False,
                              currentprefixes=None, addVocabConf=None):
        self.currentcol = column
        self.currentrow = row
        self.interlinkdialog = SearchDialog(column, row, self.triplestoreconf, self.prefixes, interlinkOrEnrich, table,
                                                propOrClass, bothOptions, currentprefixes, addVocabConf)
        self.interlinkdialog.setMinimumSize(650, 400)
        self.interlinkdialog.setWindowTitle("Search Interlink Concept")
        self.interlinkdialog.exec_()


    # def itemModelToMap(self, model):
    #     resdict = {}
    #     for row in range(model.rowCount()):
    #         index = model.index(row, 0, self)
    #         resdict[model.itemFromIndex(index).text()] = model.itemFromIndex(index).data(1)
    #     return resdict





    ##
    #  @brief Builds a boundingbox dialog allows to pick a bounding box for a SPARQL query.
    #
    #  @param self The object pointer
    def getPointFromCanvas(self):
        self.d = BBOXDialog(self.inp_sparql2, self.triplestoreconf, self.endpointCB.currentIndex())
        self.d.setWindowTitle("Choose BoundingBox")
        self.d.exec_()

# this part of code creates a menubar with an exit and file menu
        # exitAct = QAction(QIcon('exit.png'), '&Exit', self)
        # exitAct.setShortcut('Ctrl+Q')
        # exitAct.setStatusTip('Exit application')
        # exitAct.triggered.connect(qApp.quit)
        #
        # menubar = self.menuBar()
        # fileMenu = menubar.addMenu('&File')
        # fileMenu.addAction(exitAct)
        #
        # self.setGeometry(300, 300, 300, 200)
        # self.setWindowTitle('Simple menu')
        # self.show()
    ##
    #  @brief Loads a QGIS layer for interlinking into the interlinking dialog.
    #
    #  @param self The object pointer
    # def loadLayerForInterlink(self):
    #     layers = QgsProject.instance().layerTreeRoot().children()
    #     selectedLayerIndex = self.chooseLayerInterlink.currentIndex()
    #     if len(layers) == 0:
    #         return
    #     layer = layers[selectedLayerIndex].layer()
    #     try:
    #         fieldnames = [field.name() for field in layer.fields()]
    #         while self.interlinkTable.rowCount() > 0:
    #             self.interlinkTable.removeRow(0);
    #         row = 0
    #         self.interlinkTable.setHorizontalHeaderLabels(
    #             ["Export?", "IDColumn?", "GeoColumn?", "Column", "ColumnProperty", "PropertyType", "ColumnConcept",
    #              "ValueConcepts"])
    #         self.interlinkTable.setColumnCount(8)
    #         for field in fieldnames:
    #             item = QTableWidgetItem(field)
    #             item.setFlags(QtCore.Qt.ItemIsEnabled)
    #             item2 = QTableWidgetItem()
    #             item2.setCheckState(True)
    #             item3 = QTableWidgetItem()
    #             item3.setCheckState(False)
    #             item4 = QTableWidgetItem()
    #             item4.setCheckState(False)
    #             self.interlinkTable.insertRow(row)
    #             self.interlinkTable.setItem(row, 3, item)
    #             self.interlinkTable.setItem(row, 0, item2)
    #             self.interlinkTable.setItem(row, 1, item3)
    #             self.interlinkTable.setItem(row, 2, item4)
    #             cbox = QComboBox()
    #             cbox.addItem("Automatic")
    #             cbox.addItem("AnnotationProperty")
    #             cbox.addItem("DataProperty")
    #             cbox.addItem("ObjectProperty")
    #             cbox.addItem("SubClass")
    #             self.interlinkTable.setCellWidget(row, 5, cbox)
    #             currentRowCount = self.interlinkTable.rowCount()
    #             row += 1
    #     except:
    #         msgBox = QMessageBox()
    #         msgBox.setWindowTitle("Layer not compatible for interlinking!")
    #         msgBox.setText("The chosen layer is not supported for interlinking. You possibly selected a raster layer")
    #         msgBox.exec()
    #         return
