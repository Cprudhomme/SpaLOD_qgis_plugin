# -*- coding: utf-8 -*-
"""
/***************************************************************************
 SPAQLunicornDialog
                                 A QGIS plugin
 This plugin adds a GeoJSON layer from a Wikidata SPARQL query.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2019-10-28
        git sha              : $Format:%H$
        copyright            : (C) 2019 by SPARQL Unicorn
        email                : rse@fthiery.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os
import re
import json
import sys
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.PyQt import QtCore
from qgis.core import QgsProject,QgsMessageLog, Qgis
from qgis.PyQt.QtCore import QRegExp, QSortFilterProxyModel, Qt, QUrl
from qgis.PyQt.QtGui import QRegExpValidator, QStandardItemModel, QDesktopServices
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import QMainWindow, QAction, qApp, QApplication, QFrame
from qgis.PyQt.QtWidgets import QComboBox, QCompleter, QTableWidgetItem, QHBoxLayout, QPushButton, QWidget, \
    QAbstractItemView, QListView, QMessageBox, QApplication, QMenu, QAction
from rdflib.plugins.sparql import prepareQuery
from ..dialogs.whattoenrichdialog import EnrichmentDialog
from ..dialogs.convertcrsdialog import ConvertCRSDialog
from ..util.tooltipplaintext import ToolTipPlainText
from ..enrichmenttab import EnrichmentTab
from ..interlinkingtab import InterlinkingTab
from ..dialogs.triplestoredialog import TripleStoreDialog
from ..dialogs.triplestorequickadddialog import TripleStoreQuickAddDialog
from ..dialogs.searchdialog import SearchDialog
from ..util.sparqlhighlighter import SPARQLHighlighter
from ..dialogs.valuemappingdialog import ValueMappingDialog
from ..dialogs.bboxdialog import BBOXDialog
from ..dialogs.loadgraphdialog import LoadGraphDialog

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'ui/sparql_unicorn_dialog_base.ui'))

MESSAGE_CATEGORY = 'SPARQLUnicornDialog'
##
#  @brief The main dialog window of the SPARQLUnicorn QGIS Plugin.
class SPARQLunicornDialog(QtWidgets.QMainWindow, FORM_CLASS):
    ## The triple store configuration file
    triplestoreconf = None
    ## Prefix map
    prefixes = None

    enrichtab = None

    interlinktab = None

    conceptList = None

    completerClassList = None

    columnvars = {}

    # menubar = None
    #
    # fileMenu = {}



    def __init__(self, triplestoreconf={}, prefixes=[], addVocabConf={}, autocomplete={},
                 prefixstore={"normal": {}, "reversed": {}}, savedQueriesJSON={}, maindlg=None, parent=None ):
        """Constructor."""
        super(SPARQLunicornDialog, self).__init__(parent)
        self.setupUi(self)

        # self.currentIndex = QCo
        self.comboBox = QComboBox
        # self.menuBar = menuBar
        self.prefixes = prefixes
        self.maindlg = maindlg
        self.savedQueriesJSON = savedQueriesJSON
        # self.enrichtab = EnrichmentTab(self)
        # self.interlinktab = InterlinkingTab(self)
        self.addVocabConf = addVocabConf
        self.autocomplete = autocomplete
        self.prefixstore = prefixstore
        self.triplestoreconf = triplestoreconf
        self.searchTripleStoreDialog = TripleStoreDialog(self.triplestoreconf, self.prefixes, self.prefixstore,
                                                          self.comboBox)
        # self.geoTreeView.setHeaderHidden(True)
        # self.geoTreeView.setEditTriggers(QAbstractItemView.NoEditTriggers)
        # self.geoTreeView.setAlternatingRowColors(True)
        # self.geoTreeView.setWordWrap(True)
        # self.geoTreeView.setContextMenuPolicy(Qt.CustomContextMenu)
        # self.geoTreeView.customContextMenuRequested.connect(self.onContext)
        # self.geoTreeViewModel = QStandardItemModel()
        # self.geoTreeView.setModel(self.geoTreeViewModel)
        # self.featureCollectionClassListModel = QStandardItemModel()
        # self.geometryCollectionClassListModel = QStandardItemModel()
        # self.proxyModel = QSortFilterProxyModel(self)
        # self.proxyModel.sort(0)
        # self.proxyModel.setFilterCaseSensitivity(Qt.CaseInsensitive)
        # self.proxyModel.setSourceModel(self.geoTreeViewModel)
        # self.featureCollectionProxyModel = QSortFilterProxyModel(self)
        # self.featureCollectionProxyModel.sort(0)
        # self.featureCollectionProxyModel.setFilterCaseSensitivity(Qt.CaseInsensitive)
        # self.featureCollectionProxyModel.setSourceModel(self.featureCollectionClassListModel)
        # self.geometryCollectionProxyModel = QSortFilterProxyModel(self)
        # self.geometryCollectionProxyModel.sort(0)
        # self.geometryCollectionProxyModel.setFilterCaseSensitivity(Qt.CaseInsensitive)
        # self.geometryCollectionProxyModel.setSourceModel(self.geometryCollectionClassListModel)
        # self.geoTreeView.setModel(self.proxyModel)
        # self.geoTreeViewModel.clear()
        # self.rootNode = self.geoTreeViewModel.invisibleRootItem()
        # self.featureCollectionClassList.setModel(self.featureCollectionProxyModel)
        # self.featureCollectionClassList.setEditTriggers(QAbstractItemView.NoEditTriggers)
        # self.featureCollectionClassList.setAlternatingRowColors(True)
        # self.featureCollectionClassList.setWordWrap(True)
        # self.featureCollectionClassList.setContextMenuPolicy(Qt.CustomContextMenu)
        # self.featureCollectionClassList.customContextMenuRequested.connect(self.onContext)
        # self.featureCollectionClassListModel.clear()
        # self.geometryCollectionClassList.setModel(self.geometryCollectionProxyModel)
        # self.geometryCollectionClassList.setEditTriggers(QAbstractItemView.NoEditTriggers)
        # self.geometryCollectionClassList.setAlternatingRowColors(True)
        # self.geometryCollectionClassList.setWordWrap(True)
        # self.geometryCollectionClassList.setContextMenuPolicy(Qt.CustomContextMenu)
        # self.geometryCollectionClassList.customContextMenuRequested.connect(self.onContext)
        # self.geometryCollectionClassListModel.clear()
        # self.queryLimit.setValidator(QRegExpValidator(QRegExp("[0-9]*")))
        # self.filterConcepts.textChanged.connect(self.setFilterFromText)
        # self.inp_sparql2 = ToolTipPlainText(self.tab, self.triplestoreconf, self.comboBox, self.columnvars,
        #                                     self.prefixes, self.autocomplete)
        self.inp_sparql2.move(10, 130)
        self.inp_sparql2.setMinimumSize(780, 431)
        self.inp_sparql2.document().defaultFont().setPointSize(16)
        self.inp_sparql2.setPlainText(
            "SELECT ?item ?lat ?lon WHERE {\n ?item ?b ?c .\n ?item <http://www.wikidata.org/prop:P123> ?def .\n}")
        self.inp_sparql2.columnvars = {}
        self.inp_sparql2.textChanged.connect(self.validateSPARQL)
        self.sparqlhighlight = SPARQLHighlighter(self.inp_sparql2)
        # self.areaconcepts.hide()
        # self.areas.hide()
        # self.label_8.hide()
        # self.label_9.hide()
        # self.savedQueries.hide()
        # self.loadQuery.hide()
        # self.saveQueryButton.hide()
        # self.saveQueryName.hide()
        # self.savedQueryLabel.hide()
        # self.saveQueryName_2.hide()
        # self.enrichTableResult.hide()
        # self.queryTemplates.currentIndexChanged.connect(self.viewselectaction)
        # self.bboxButton.clicked.connect(self.getPointFromCanvas)
        # self.interlinkTable.cellClicked.connect(self.createInterlinkSearchDialog)
        # self.enrichTable.cellClicked.connect(self.createEnrichSearchDialog)
        # self.convertTTLCRS.clicked.connect(self.buildConvertCRSDialog)
        # self.chooseLayerInterlink.clear()
        # self.searchClass.clicked.connect(self.createInterlinkSearchDialog)
        urlregex = QRegExp("http[s]?://(?:[a-zA-Z#]|[0-9]|[$-_@.&+]|[!*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+")
        urlvalidator = QRegExpValidator(urlregex, self)
        # self.interlinkNameSpace.setValidator(urlvalidator)
        # self.interlinkNameSpace.textChanged.connect(self.check_state3)
        # self.interlinkNameSpace.textChanged.emit(self.interlinkNameSpace.text())
        # self.addEnrichedLayerButton.clicked.connect(self.enrichtab.addEnrichedLayer)
        # self.startEnrichment.clicked.connect(self.enrichtab.enrichLayerProcess)
        # self.exportInterlink.clicked.connect(self.enrichtab.exportEnrichedLayer)
        # self.loadQuery.clicked.connect(self.loadQueryFunc)
        # self.saveQueryButton.clicked.connect(self.saveQueryFunc)
        # self.exportMappingButton.clicked.connect(self.interlinktab.exportMapping)
        # self.importMappingButton.clicked.connect(self.interlinktab.loadMapping)
        # self.loadLayerInterlink.clicked.connect(self.loadLayerForInterlink)
        # self.loadLayerEnrich.clicked.connect(self.loadLayerForEnrichment)
        # self.addEnrichedLayerRowButton.clicked.connect(self.addEnrichRow)
        # self.geoTreeView.selectionModel().currentChanged.connect(self.viewselectaction)
        # self.loadFileButton.clicked.connect(self.buildLoadGraphDialog)
        # self.refreshLayersInterlink.clicked.connect(self.loadUnicornLayers)
        # self.btn_loadunicornlayers.clicked.connect(self.loadUnicornLayers)
        # self.whattoenrich.clicked.connect(self.createWhatToEnrich)
        # self.quickAddTripleStore.clicked.connect(self.buildQuickAddTripleStore)
        # self.loadTripleStoreButton.clicked.connect(self.buildCustomTripleStoreDialog)
        #self.loadUnicornLayers()
        self.actionLoad_Graph.triggered.connect(self.buildLoadGraphDialog)
        self.actionAdd_Endpoint.triggered.connect(self.buildQuickAddTripleStore)
        self.loadTripleStoreButton.clicked.connect(self.buildCustomTripleStoreDialog)
        self.saveQueryButton.clicked.connect(self.saveQueryFunc)
        self.actionConvert_TTL_CRS.triggered.connect(self.buildConvertCRSDialog)
        # self.bboxButton.clicked.connect(self.getPointFromCanvas)

        ##
        #  @brief Creates a What To Enrich dialog with parameters given.
        #
        #  @param self The object pointer
    def buildLoadGraphDialog(self):
        self.searchTripleStoreDialog = LoadGraphDialog(self.triplestoreconf, self.maindlg, self)
        self.searchTripleStoreDialog.setWindowTitle("Load Graph")
        self.searchTripleStoreDialog.exec_()

##
#  @brief Creates a What To Enrich dialog with parameters given.
#
#  @param self The object pointer
    def buildQuickAddTripleStore(self):
        self.searchTripleStoreDialog = TripleStoreQuickAddDialog(self.triplestoreconf, self.prefixes, self.prefixstore,
        self.comboBox)
        self.searchTripleStoreDialog.setMinimumSize(580, 186)
        self.searchTripleStoreDialog.setWindowTitle("Configure Own Triple Store")
        self.searchTripleStoreDialog.exec_()

# builds the "buildCustomTripleStoreDialog" which pops up when the user clicks on the "loadTripleStoreButton" (Configure Triple)
    def buildCustomTripleStoreDialog(self):
        self.searchTripleStoreDialog = TripleStoreDialog(self.triplestoreconf, self.prefixes, self.prefixstore,
                                                         self.comboBox)
        self.searchTripleStoreDialog.setMinimumSize(700, 500)
        self.searchTripleStoreDialog.setWindowTitle("Configure Own Triple Store")
        self.searchTripleStoreDialog.exec_()

# this functions allows us to save the users queries in a json.dump
    def saveQueryFunc(self):
        queryName = self.saveQueryName.text()
        if queryName is not None and queryName != "":
            __location__ = os.path.realpath(os.path.join(os.getcwd(), os.path.dirname(__file__)))
            if not self.triplestoreconf[self.comboBox.currentIndex()]["endpoint"] in self.savedQueriesJSON:
                self.savedQueriesJSON[self.triplestoreconf[self.comboBox.currentIndex()]["endpoint"]] = []
            self.savedQueriesJSON[self.triplestoreconf[self.comboBox.currentIndex()]["endpoint"]].append(
                {"label": queryName, "query": self.inp_sparql2.toPlainText()})
            self.savedQueries.addItem(queryName)
            f = open(os.path.join(__location__, 'savedqueries.json'), "w")
            f.write(json.dumps(self.savedQueriesJSON))
            f.close()

# creates the dialog for converting CRS
    def buildConvertCRSDialog(self):
        self.searchTripleStoreDialog = ConvertCRSDialog(self.triplestoreconf, self.maindlg, self)
        self.searchTripleStoreDialog.setWindowTitle("Convert CRS")
        self.searchTripleStoreDialog.exec_()

    ## Validates the SPARQL query in the input field and outputs errors in a label.
    #  @param self The object pointer.
    def validateSPARQL(self):
        if self.prefixes is not None and self.comboBox is not None and self.comboBox.currentIndex() is not None and self.prefixes[
            self.comboBox.currentIndex()] is not None and self.inp_sparql2.toPlainText() is not None and self.inp_sparql2.toPlainText() != "":
            try:
                if self.prefixes[self.comboBox.currentIndex()] != "":
                    prepareQuery(
                        "".join(self.prefixes[self.comboBox.currentIndex()]) + "\n" + self.inp_sparql2.toPlainText())
                self.errorLabel.setText("Valid Query")
                self.errorline = -1
                self.sparqlhighlight.errorhighlightline = self.errorline
                self.sparqlhighlight.currentline = 0
                self.inp_sparql2.errorline = None
            except Exception as e:
                match = re.search(r'line:([0-9]+),', str(e))
                match2 = re.search(r'col:([0-9]+),', str(e))
                start = int(match.group(1)) - len(self.triplestoreconf[self.comboBox.currentIndex()]["prefixes"]) - 1
                self.errorLabel.setText(re.sub("line:([0-9]+),", "line: " + str(start) + ",", str(e)))
                self.inp_sparql2.errorline = start - 1
                if "line" in str(e):
                    ex = str(e)
                    start = ex.find('line:') + 5
                    end = ex.find(',', start)
                    start2 = ex.find('col:') + 4
                    end2 = ex.find(')', start2)
                    self.errorline = ex[start:end]
                    self.sparqlhighlight.errorhighlightcol = ex[start2:end2]
                    self.sparqlhighlight.errorhighlightline = self.errorline
                    self.sparqlhighlight.currentline = 0



    # def viewselectaction(self,selected=None, deselected=None):
    #     endpointIndex = self.comboBox.currentIndex()
    #     if endpointIndex == 0:
    #         self.justloadingfromfile = False
    #         return
    #     concept = ""
    #     curindex = self.proxyModel.mapToSource(self.geoTreeView.selectionModel().currentIndex())
    #     if self.geoTreeView.selectionModel().currentIndex() is not None and self.geoTreeViewModel.itemFromIndex(
    #             curindex) is not None and re.match(r'.*Q[0-9]+.*', self.geoTreeViewModel.itemFromIndex(
    #         curindex).text()) and not self.geoTreeViewModel.itemFromIndex(curindex).text().startswith("http"):
    #         self.inp_label.setText(
    #             self.geoTreeViewModel.itemFromIndex(curindex).text().split("(")[0].lower().replace(" ", "_"))
    #         concept = "Q" + self.geoTreeViewModel.itemFromIndex(curindex).text().split("Q")[1].replace(")", "")
    #     elif self.geoTreeViewModel.itemFromIndex(curindex) is not None:
    #         concept = self.geoTreeViewModel.itemFromIndex(curindex).data(1)
    #     if "querytemplate" in self.triplestoreconf[endpointIndex]:
    #         if "wd:Q%%concept%% ." in \
    #                 self.triplestoreconf[endpointIndex]["querytemplate"][self.queryTemplates.currentIndex()]["query"]:
    #             querytext = ""
    #             if concept != None and concept.startswith("http"):
    #                 querytext = \
    #                     self.triplestoreconf[endpointIndex]["querytemplate"][self.queryTemplates.currentIndex()][
    #                         "query"].replace("wd:Q%%concept%% .", "wd:" + concept[concept.rfind('/') + 1:] + " .")
    #             elif concept != None:
    #                 querytext = \
    #                     self.triplestoreconf[endpointIndex]["querytemplate"][self.queryTemplates.currentIndex()][
    #                         "query"].replace("wd:Q%%concept%% .", "wd:" + concept + " .")
    #         else:
    #             querytext = self.triplestoreconf[endpointIndex]["querytemplate"][self.queryTemplates.currentIndex()][
    #                 "query"].replace("%%concept%%", concept)
    #         if self.queryLimit.text().isnumeric() and querytext.rfind("LIMIT") != -1:
    #             querytext = querytext[0:querytext.rfind("LIMIT")] + "LIMIT " + self.queryLimit.text()
    #         elif self.queryLimit.text().isnumeric() and querytext.rfind("LIMIT") == -1:
    #             querytext = querytext + " LIMIT " + self.queryLimit.text()
    #         self.inp_sparql2.setPlainText(querytext)
    #         self.inp_sparql2.columnvars = {}
    #     if self.geoTreeView.selectionModel().currentIndex() is not None and self.geoTreeViewModel.itemFromIndex(
    #             curindex) is not None and "#" in self.geoTreeViewModel.itemFromIndex(curindex).text():
    #         self.inp_label.setText(self.geoTreeViewModel.itemFromIndex(curindex).text()[
    #                                self.geoTreeViewModel.itemFromIndex(curindex).text().rfind(
    #                                    '#') + 1:].lower().replace(" ", "_"))
    #     elif self.geoTreeView.selectionModel().currentIndex() is not None and self.geoTreeViewModel.itemFromIndex(
    #             curindex) is not None:
    #         self.inp_label.setText(self.geoTreeViewModel.itemFromIndex(curindex).text()[
    #                                self.geoTreeViewModel.itemFromIndex(curindex).text().rfind(
    #                                    '/') + 1:].lower().replace(" ", "_"))

    # def itemModelToMap(self, model):
    #     resdict = {}
    #     for row in range(model.rowCount()):
    #         index = model.index(row, 0, self)
    #         resdict[model.itemFromIndex(index).text()] = model.itemFromIndex(index).data(1)
    #     return resdict





    ##
    #  @brief Builds a boundingbox dialog allows to pick a bounding box for a SPARQL query.
    #
    #  @param self The object pointer
    # def getPointFromCanvas(self):
    #     self.d = BBOXDialog(self.inp_sparql2, self.triplestoreconf, self.comboBox.currentIndex())
    #     self.d.setWindowTitle("Choose BoundingBox")
    #     self.d.exec_()

# this part of code creates a menubar with an exit and file menu
        # exitAct = QAction(QIcon('exit.png'), '&Exit', self)
        # exitAct.setShortcut('Ctrl+Q')
        # exitAct.setStatusTip('Exit application')
        # exitAct.triggered.connect(qApp.quit)
        #
        # menubar = self.menuBar()
        # fileMenu = menubar.addMenu('&File')
        # fileMenu.addAction(exitAct)
        #
        # self.setGeometry(300, 300, 300, 200)
        # self.setWindowTitle('Simple menu')
        # self.show()
